; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName MYAPP_NAME
#define MyAppVersion MYAPP_VERSION
#define MyAppPublisher "Canon, Inc."
#define MyAppURL "https://www.canon.com/"
#define MyAppExeName "AnalysisTool_Launcher.exe"
#define MyAppErrorMsgIsWin32 "You already have a 32 bit installation of pgAdmin 4. Please uninstall this before installing the 64 bit version."
#define MyAppErrorMsgIsWin64 "You already have a 64 bit installation of pgAdmin 4. Please uninstall this before installing the 32 bit version."
#define PostgreSQLInstaller "postgresql-10.16-1-windows-x64.exe"
#define MyAppArchitecturesMode MYAPP_ARCHITECTURESMODE

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{27BA6D7E-DBC7-4AF0-A6CC-6CA5A7C5DBCB}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName=C:\{#MyAppName}
DisableDirPage=yes
DisableProgramGroupPage=yes
LicenseFile=..\win-build\LICENSE.md
InfoAfterFile=..\win-build\README.md
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
;OutputDir=D:\temp\mpaanalysistool
;OutputBaseFilename={#MyAppInstallerName}
Compression=lzma
SolidCompression=yes
WizardStyle=modern
ArchitecturesAllowed=x64
ArchitecturesInstallIn64BitMode={#MyAppArchitecturesMode}
PrivilegesRequired=admin

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "..\win-build\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

;This section would be used for customized error message display.
[CustomMessages]
english.NewerVersionExists=A newer version of {#MyAppName}
english.SameVersionExists=The same version of {#MyAppName}

[Icons]
Name: "{autoprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\installer\{#PostgreSQLInstaller}"; StatusMsg: "{#PostgreSQLInstaller} is installing.."; Parameters: ""; Check: InstallPG;
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent

[Registry]
Root: HKLM; Subkey: "Software\{#MyAppName}"; Flags: uninsdeletekeyifempty
Root: HKLM; Subkey: "Software\{#MyAppName}"; Flags: uninsdeletekey
Root: HKLM; Subkey: "Software\{#MyAppName}"; ValueType: string; ValueName: "InstallPath"; ValueData: "{app}"
Root: HKLM; Subkey: "Software\{#MyAppName}"; ValueType: string; ValueName: "Version"; ValueData: "{#MyAppVersion}"

[Code]
var
  UpgradeMode: Boolean;

// Procedure to split a string into an array of integers
procedure Explode(var Dest: TArrayOfInteger; Text: String; Separator: String);
var
  i, p: Integer;
begin
  i := 0;
  repeat
    SetArrayLength(Dest, i+1);
    p := Pos(Separator,Text);
    if p > 0 then begin
      Dest[i] := StrToInt(Copy(Text, 1, p-1));
      Text := Copy(Text, p + Length(Separator), Length(Text));
      i := i + 1;
    end else begin
      Dest[i] := StrToInt(Text);
      Text := '';
    end;
  until Length(Text)=0;
end;

// Function compares version strings numerically:
//     * when v1 = v2, result = 0
//     * when v1 < v2, result = -1
//     * when v1 > v2, result = 1
//
// Supports version numbers with trailing zeroes, for example 1.02.05.
// Supports comparison of two version number of different lengths,
// for example CompareVersions('1.2', '2.0.3')
// When any of the parameters is '' (empty string) it considers version
// number as 0
function CompareVersions(v1: String; v2: String): Integer;
var
  v1parts: TArrayOfInteger;
  v2parts: TArrayOfInteger;
  i: Integer;
begin
  if v1 = '' then
  begin
    v1 := '0';
  end;

  if v2 = '' then
  begin
    v2 := '0';
  end;

  Explode(v1parts, v1, '.');
  Explode(v2parts, v2, '.');

  if (GetArrayLength(v1parts) > GetArrayLength(v2parts)) then
  begin
    SetArrayLength(v2parts, GetArrayLength(v1parts))
  end else if (GetArrayLength(v2parts) > GetArrayLength(v1parts)) then
  begin
    SetArrayLength(v1parts, GetArrayLength(v2parts))
  end;

  for i := 0 to GetArrayLength(v1parts) - 1 do
  begin
    if v1parts[i] > v2parts[i] then
    begin
      { v1 is greater }
      Result := 1;
      exit;
    end else if v1parts[i] < v2parts[i] then
    begin
      { v2 is greater }
      Result := -1;
      exit;
    end;
  end;

  { Are Equal }
  Result := 0;
end;

function CheckPgAdminAlreadyInstalled: Boolean;
var
  Version: String;
  InstallationFound: Boolean;
begin
  InstallationFound := False;
  // Check the installation mode 64 or 32 bit of installer
  if Is64BitInstallMode then
  begin

    // Check if pgAdmin 32 bit is already installed
    RegQueryStringValue(HKLM32,'Software\{#MyAppName}', 'Version', Version);

    // If version is found then shouldn't install 64bit - abort
    if Length(Version) > 0 then
    begin
      MsgBox(ExpandConstant('{#MyAppErrorMsgIsWin32}'), mbCriticalError, MB_OK);
	  Result := False;
	  InstallationFound := True;
    end;
  end
  else
  begin
    // Suppose system is running a 32-bit version of Windows then no need to check HKLM64 in RegQueryStringValue
    // So IsWin64 - will make sure its should only execute on 64-bit veersion of windows.
    if IsWin64 then
	begin
        // Check if pgAdmin 64 bit is already installed
        RegQueryStringValue(HKLM64,'Software\{#MyAppName}', 'Version', Version);

        // If version is found the shouldn't install 32bit - abort
        if Length(Version) > 0 then
        begin
          MsgBox(ExpandConstant('{#MyAppErrorMsgIsWin64}'), mbCriticalError, MB_OK);
	      Result := False;
	      InstallationFound := True;
	    end;
	end;
 end;

  if  not (InstallationFound) then
  begin
     if RegValueExists(HKEY_LOCAL_MACHINE,'Software\{#MyAppName}', 'Version') then
     begin
       UpgradeMode := True;
       RegQueryStringValue(HKEY_LOCAL_MACHINE,'Software\{#MyAppName}', 'Version', Version);
       if CompareVersions(Version, '{#MyAppVersion}') = 1 then
       begin         
         MsgBox(ExpandConstant('{cm:NewerVersionExists}' + '(v' + Version + ') is already installed' ), mbInformation, MB_OK);
         Result := False;
       end
       else if CompareVersions(Version, '{#MyAppVersion}') = 0 then
       begin
         MsgBox(ExpandConstant('{cm:SameVersionExists}' + '(v' + Version + ') is already installed' ), mbInformation, MB_OK);
         Result := False;
       end
	   else
       begin
        Result := True;
       end;
     end;
  end;

  if  ( not (InstallationFound) and not (UpgradeMode) ) then
  begin
   // This is required as it will be passed on to the InitializeSetup function
   Result := True;
  end;
end;

// Find current version before installation
function InitializeSetup: Boolean;
begin
    Result := CheckPgAdminAlreadyInstalled;
end;

function IsUpgradeMode(): Boolean;
begin
  Result := UpgradeMode;
end;

function InstallPG: Boolean;
begin
  Result := True;
end;

// This function would be called during upgrade mode
// In upgrade mode - delete config/* and exclude db_config.conf
procedure DelConfigfolder(Path: string);
var
  FindRec: TFindRec;
  FilePath: string;
begin
  if FindFirst(Path + '\*', FindRec) then
  begin
    try
      repeat
        if (FindRec.Name <> '.') and (FindRec.Name <> '..') then
        begin
          FilePath := Path + '\' + FindRec.Name;
          if FindRec.Attributes and FILE_ATTRIBUTE_DIRECTORY = 0 then
          begin
            if CompareText(FindRec.Name, 'db_config.conf') <> 0 then
            begin
              DeleteFile(FilePath);
            end
          end
          else
            begin
              DelConfigfolder(FilePath);
              RemoveDir(FilePath);
            end;
          end;
        until not FindNext(FindRec);
      finally
      FindClose(FindRec);
    end;
  end;
end;

// This function would be called during upgrade mode
// In upgrade mode - delete venv/*, web/* for example
procedure DelFolder(Path: string);
var
  FindRec: TFindRec;
  FilePath: string;
begin
  if FindFirst(Path + '\*', FindRec) then
  begin
    try
      repeat
        if (FindRec.Name <> '.') and (FindRec.Name <> '..') then
        begin
          FilePath := Path + '\' + FindRec.Name;
          if FindRec.Attributes and FILE_ATTRIBUTE_DIRECTORY = 0 then
          begin
            DeleteFile(FilePath);
          end
          else
            begin
              DelFolder(FilePath);
              RemoveDir(FilePath);
            end;
          end;
        until not FindNext(FindRec);
      finally
      FindClose(FindRec);
    end;
  end;
end;

//procedure CurPageChanged(CurPageID: Integer);
function NextButtonClick(CurPageID: Integer): Boolean;
var
  Ret: Boolean;
begin
  Ret := True;
  case CurPageID of
    wpReady:
      begin
          if (IsUpgradeMode) then
          begin
            DelFolder(ExpandConstant('{app}\web'));
            DelFolder(ExpandConstant('{app}\venv'));
            DelFolder(ExpandConstant('{app}\common'));
            DelConfigfolder(ExpandConstant('{app}\config'));
            DelFolder(ExpandConstant('{app}\controller'));
            DelFolder(ExpandConstant('{app}\dao'));
            DelFolder(ExpandConstant('{app}\flaskapp'));
            DelFolder(ExpandConstant('{app}\resource'));
            DelFolder(ExpandConstant('{app}\service'));
            DelFolder(ExpandConstant('{app}\convert'));
			DelFolder(ExpandConstant('{app}\installer'));
			DelFolder(ExpandConstant('{app}\migrations'));
          end;
      end;
  end;

  Result := Ret;
end;

// End of program